#!/bin/bash

# Set options:

# Fail on a single failed command in a pipeline
set -o pipefail

# Save global script args
ARGS="$@"

# Fail on error and undefined vars (please don't use global vars, but
# evaluation of functions for return values)
set -eu

function check_cmd_existence() {
  local commands="$@"


}

# Main loop evaluating sub commands
run() {
  local args="$@"
  local commands=()
  for arg in $args; do
    if [[ ${arg} != -* ]]; then
      commands+=("${arg}")
    fi
  done

  if [[ ${#commands[@]} -eq 0 ]]; then
    commands+=("help")
    echo "No command given"
  fi
    echo

  if [ "${commands[0]}" = "help" ] || $(hasflag --help -h); then
    display_help ${command:-}
    exit 0
  fi

  local cmd_dir="$(basedir)/commands"
  local valid_cmd_parts=()
  for cmd in $commands; do
    local path

    if [[ ${#valid_cmd_parts[@]} -eq 0 ]]; then
      path=$(join_by '/' "$cmd")
    else
      path=$(join_by '/' "${valid_cmd_parts[@]} $cmd")
    fi

    if [[ ! -e "$cmd_dir/$path" ]]; then
      echo BREAK OUT!
      exit 1
    else
      echo "cool: $cmd_dir/$path"
      valid_cmd_parts+=("${cmd}")
    fi
  done

  path=$(join_by '/' "${valid_cmd_parts[@]}")
  execution_path=$(join_by '::' "${valid_cmd_parts[@]}")

  echo $cmd_dir/$path
  if [[ -d "$cmd_dir/$path" ]]; then
    source "$cmd_dir/$path/init"
    display_help $(join_by ' ' "${valid_cmd_parts[@]}")
  elif [[ -f ${path} ]]; then
    source "$cmd_dir/$path"
    eval "${execution_path}::run"
  else
    echo
    echo ">>>> Unknown command '$(join_by ' ' "${valid_cmd_parts[@]}")'"
    echo
    display_help
    exit 1
  fi

  
  echo  "$cmd_dir/$path"
  echo "${execution_path}::run"
  
}


# TODO print usage of subcommand

display_help() {
  local command=${1:-}
  local cmd_dir="$(basedir)/commands"

  if [ -z "${command}" ] || [ "$command" = "help" ]; then
    cat << EOT
Usage: kdeploy <subcommand> <opts>

Kubernetes deployment helper

Commands:
EOT
    for cmd in $(ls $cmd_dir); do
      if [ -f $cmd_dir/$cmd ]; then
        source $cmd_dir/$cmd
        printf "   %-15s  %s\n" $cmd "$($cmd::description)"
      fi
    done
    printf "   %-15s  %s\n" "help" "Print this help message"
  else
    source $cmd_dir/$command
    cat <<EOT
$($command::description)

Usage: kdeploy $command [... options ...]

EOT
    echo "Options for $command:"
    echo -e "$($command::usage)"
  fi

  cat <<EOT

Global Options:

  -h --help                 Print this help message
EOT
}

# Directory where this script is located
basedir() {
    # Default is current directory
    local script=${BASH_SOURCE[0]}

    # Resolve symbolic links
    if [ -L $script ]; then
        if readlink -f $script >/dev/null 2>&1; then
            script=$(readlink -f $script)
        elif readlink $script >/dev/null 2>&1; then
            script=$(readlink $script)
        elif realpath $script >/dev/null 2>&1; then
            script=$(realpath $script)
        else
            echo "ERROR: Cannot resolve symbolic link $script"
            exit 1
        fi
    fi

    local dir=$(dirname "$script")
    local full_dir=$(cd "${dir}" && pwd)
    echo ${full_dir}
}

# ===========================================================
# Startup ...

# Read in some helpers
source $(basedir)/helpers.sh

if $(hasflag --verbose -v); then
    export PS4='+($(basename ${BASH_SOURCE[0]}):${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
    set -x
fi

run $ARGS
